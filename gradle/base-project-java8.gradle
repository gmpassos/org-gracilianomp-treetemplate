
buildscript {
	repositories {
		maven {
			url(project.hasProperty('nexusUrl') ? "${nexusUrl}/content/groups/public" : 'http://nexus.coing4.gold/content/groups/public')
		}
	}
}

apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'idea'
apply plugin: 'eclipse-wtp'
apply plugin: 'project-report'
apply plugin: 'jacoco'

sourceCompatibility = 1.8
[compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'

task wrapper(type: Wrapper) {
	gradleVersion = '4.3'
}

project.ext {
	DEV_ENVIRONMENT = 'DEV'
	PROD_ENVIRONMENT = 'PROD'
	UNDEFINED = 'undefined'
}

ext {
	theNexusUrl = project.hasProperty('nexusUrl') ? "${nexusUrl}" : 'http://nexus.coing4.gold'
	theNexusRepository = project.hasProperty('nexusRepository') ? "${nexusRepository}" : UNDEFINED
	theNexusGroup = project.hasProperty('nexusGroup') ? "${nexusGroup}" : 'public'
	theNexusUsername = project.hasProperty('nexusUsername') ? "${nexusUsername}" : 'admin'
	theNexusPassword = project.hasProperty('nexusPassword') ? "${nexusPassword}" : 'admin123'

	theReleaseNumber = project.hasProperty('releaseNumber') ? "${releaseNumber}" : UNDEFINED
	theVersionSuffix = project.hasProperty('versionSuffix') ? "${versionSuffix}" : UNDEFINED
	theArtifactSuffix = project.hasProperty('artifactSuffix') ? "${artifactSuffix}" : UNDEFINED
	theEnvironment = project.hasProperty('environment') ? "${environment}" : UNDEFINED

	if (theEnvironment == PROD_ENVIRONMENT) {
		theVersionSuffix = ''
		theArtifactSuffix = ''
		theNexusRepository = 'releases'
	}
	else if (theEnvironment == DEV_ENVIRONMENT) {
		theVersionSuffix = '-SNAPSHOT'
		theArtifactSuffix = '-SNAPSHOT'
		theNexusRepository = 'snapshots'
	}
	else if (theEnvironment == UNDEFINED) {
		theVersionSuffix = '-LOCAL'
		theArtifactSuffix = '-SNAPSHOT'
		theNexusRepository = UNDEFINED
	}
	else {
		throw new RuntimeException("Invalid build environment [${theEnvironment}]!")
	}
}

version = "${theReleaseNumber}${theVersionSuffix}"

sourceSets {
  integrationTest {
    java {
    	compileClasspath += main.output + test.output
    	runtimeClasspath += main.output + test.output
    	srcDir file('src/it/java')
		
		integrationTest.runtimeClasspath += integrationTest.output
    }
    resources.srcDir file('src/it/resources')
  }
}

configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}

configurations.all {
	resolutionStrategy {
		eachDependency { DependencyResolveDetails details ->
			def requested = details.requested
			if (requested.group == 'com.coin4gold') {
				def requestedVersion = requested.version
				if (!requestedVersion.contains('-') && theArtifactSuffix != '') {
					details.useVersion "${requestedVersion}${theArtifactSuffix}"
				}
			}
		}

		cacheDynamicVersionsFor 600, 'seconds'
		cacheChangingModulesFor 600, 'seconds'
	}
}

task sourcesJar(type: Jar, dependsOn: classes) {
	classifier = 'sources'
	from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	classifier = 'javadoc'
	from javadoc.destinationDir
}

task showVersion {
	doLast{
		println "${project.version}"
	}
}

task integrationTest(type: Test) {
    group 'Verification'
    description 'Runs the integration tests.'
    testClassesDirs += sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
}

tasks.withType(Test) {
	// This exists to separate unit test reporting from integration tests
	reports.html.destination = file("${reporting.baseDir}/${name}")
}

artifacts {
	archives sourcesJar
	archives javadocJar
}

repositories {
	mavenLocal()
	/*
	maven {
		url "${theNexusUrl}/content/groups/${theNexusGroup}"
		credentials {
			username "${theNexusUsername}"
			password "${theNexusPassword}"
		}
	}
	*/
	mavenCentral()
	/*
	maven {
		url "http://maven.vaadin.com/vaadin-addons"
	}
	maven {
		url "http://oss.sonatype.org/content/repositories/vaadin-snapshots"
	}
	*/
}

uploadArchives {
	repositories.mavenDeployer {
		repository(url: "${theNexusUrl}/content/repositories/${theNexusRepository}") {
			authentication(userName: "${theNexusUsername}", password: "${theNexusPassword}")
		}
	}
}

install {
	repositories.mavenInstaller {
		pom.version = "${version}"
	}
}

eclipse {
	classpath {
		downloadSources = true
		downloadJavadoc = true
                plusConfigurations.add configurations.integrationTestCompile
                plusConfigurations.add configurations.integrationTestRuntime
	}
}

idea {
	module {
		downloadJavadoc = true
		downloadSources = true
		testSourceDirs += sourceSets.integrationTest.java.srcDirs
		testSourceDirs += sourceSets.integrationTest.resources.srcDirs
		scopes.TEST.plus.add(configurations.integrationTestCompileClasspath)
	}
}

jacoco {
	reportsDir = file("$buildDir/reports/jacoco")
}

task jacocoIntegrationTestReport(type: JacocoReport){
    sourceSets sourceSets.integrationTest
    executionData integrationTest
}

ext.runOSCommand = { command, directory ->
	def output = null
	try {
		def process = Runtime.getRuntime().exec(command, null, directory)
		process.waitForOrKill(5000)
		def exitValue = process.exitValue()
		def errorMessage = process.err.text;
		if (exitValue || errorMessage?.trim()) {
			errorMessage = errorMessage.replace("\n", " ")
			if (errorMessage.length() > 100) {
				errorMessage = errorMessage.substring(0, 95) + " ..."
			}
			println "OS command [${command}] exited with code ${exitValue}. Error output: ${errorMessage}."
			} else {
				output = process.text.trim()
			}
			} catch (Exception ex) {
				println "Error running OS command [${command}]. Error message: ${ex.message}."
			}
			return (output ? output : UNDEFINED)
		}

ext.getCommitHash = { project ->
	return runOSCommand("git rev-parse --short HEAD", project.projectDir)
}

ext.getFormatedCommitTimestamp = { project, format ->
	def commitDateString = runOSCommand("git log -1 --format=%cd HEAD", project.projectDir)
	if (commitDateString != UNDEFINED) {
		def commitDate = new java.text.SimpleDateFormat("EE MMM dd HH:mm:ss yyyy Z", Locale.US).parse(commitDateString)
		return commitDate.format(format, TimeZone.getTimeZone('GMT'))
	}
	return UNDEFINED
}

ext.getCommitTimestamp = { project ->
	return getFormatedCommitTimestamp(project, "yyyyMMddHHmm")
}

ext.getShortCommitTimestamp = { project ->
	return getFormatedCommitTimestamp(project, "yyyyMMdd")
}

task validateReleaseNumber(){
	doLast {
		if(theEnvironment == DEV_ENVIRONMENT) {
			def tags = runOSCommand('git tag', project.projectDir)
			def tagsList = tags.split("\n")
			def currentRelease = theReleaseNumber.replaceAll("'", "").replaceAll('"', '')
			tagsList.each {
				if(it == currentRelease.toString()) {
					throw new GradleException("A tag with release number ${theReleaseNumber} already exists, please increment the releaseNumber of this project on gradle.properties")
				}
			}
		}
	}
}

compileJava.dependsOn validateReleaseNumber